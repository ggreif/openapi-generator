// {{classname}}.mo
{{#description}}
/// {{{description}}}
{{/description}}

import Text "mo:core/Text";
import Int "mo:core/Int";
import Array "mo:core/Array";
import Error "mo:core/Error";
import { JSON } "mo:serde";
{{#useDfx}}
import { type CanisterHttpRequestArgument; type CanisterHttpResponsePayload; type HttpMethod; type HttpHeader; http_request } "ic:aaaaa-aa";
{{/useDfx}}
{{#imports}}
{{#isMap}}import { type Map } "mo:core/pure/Map";
{{/isMap}}{{^isMappedType}}import { type {{classname}} } "../Models/{{classname}}";
{{/isMappedType}}
{{/imports}}

module {
{{^useDfx}}
    // Management Canister interface for HTTP outcalls
    // Based on types in https://github.com/dfinity/sdk/blob/master/src/dfx/src/util/ic.did
    type HttpHeader = {
        name : Text;
        value : Text;
    };

    type HttpMethod = {
        #get;
        #head;
        #post;
        // TODO: IC HTTP outcalls currently only support GET, HEAD, and POST.
        //   PUT and DELETE methods are not yet supported by the management canister.
        //   Once support is added, uncomment these:
        // #put;
        // #delete;
    };

    type CanisterHttpRequestArgument = {
        url : Text;
        max_response_bytes : ?Nat64;
        method : HttpMethod;
        headers : [HttpHeader];
        body : ?Blob;
        transform : ?{
            function : shared query ({ response : CanisterHttpResponsePayload; context : Blob }) -> async CanisterHttpResponsePayload;
            context : Blob;
        };
        is_replicated : ?Bool;
    };

    type CanisterHttpResponsePayload = {
        status : Nat;
        headers : [HttpHeader];
        body : Blob;
    };

    let http_request = (actor "aaaaa-aa" : actor { http_request : (CanisterHttpRequestArgument) -> async CanisterHttpResponsePayload }).http_request;

{{/useDfx}}
{{#operations}}
    type Config__ = {
        baseUrl : Text;
        accessToken : ?Text;
        max_response_bytes : ?Nat64;
        transform : ?{
            function : shared query ({ response : CanisterHttpResponsePayload; context : Blob }) -> async CanisterHttpResponsePayload;
            context : Blob;
        };
        is_replicated : ?Bool;
        cycles : Nat;
    };
{{#operation}}
    {{#summary}}
    /// {{{summary}}}
    {{/summary}}
    {{#notes}}
    /// {{{notes}}}
    {{/notes}}
    public func {{operationId}}(config : Config__{{#allParams}}, {{paramName}} : {{#isNullable}}?{{/isNullable}}{{dataType}}{{/allParams}}) : async* {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}(){{/returnType}} {
        let {baseUrl; accessToken; cycles} = config;
        let url = baseUrl # "{{path}}"{{#pathParams}}
            |> Text.replace(_, #text "{{=<% %>=}}{<%baseName%>}<%={{ }}=%>", {{#isString}}{{paramName}}{{/isString}}{{^isString}}{{#isInteger}}Int.toText({{paramName}}){{/isInteger}}{{^isInteger}}debug_show({{paramName}}){{/isInteger}}{{/isString}}){{/pathParams}};

        let baseHeaders = [
            { name = "Content-Type"; value = "application/json" }{{#headerParams}},
            { name = "{{baseName}}"; value = {{#isString}}{{paramName}}{{/isString}}{{^isString}}debug_show({{paramName}}){{/isString}} }{{/headerParams}}
        ];

        // Add Authorization header if access token is provided
        let headers = switch (accessToken) {
            case (?token) {
                Array.flatten([baseHeaders, [{ name = "Authorization"; value = "Bearer " # token }]]);
            };
            case null { baseHeaders };
        };

        let request : CanisterHttpRequestArgument = { config with
            url;
            method = #{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}};
            headers;
            body = {{#bodyParam}}do ? { let candidBlob = to_candid({{paramName}}); let #ok(jsonText) = JSON.toText(candidBlob, [], null) else throw Error.reject("Failed to serialize to JSON"); Text.encodeUtf8(jsonText) }{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}};
        };

        // Call the management canister's http_request method with cycles
        {{#returnType}}let response : CanisterHttpResponsePayload = {{/returnType}}{{^returnType}}ignore {{/returnType}}await (with cycles) http_request(request);

        {{#returnType}}
        // Parse JSON response
        let responseText = switch (Text.decodeUtf8(response.body)) {
            case (?text) text;
            case null throw Error.reject("Failed to decode response body as UTF-8");
        };

        let jsonBlob = switch (JSON.fromText(responseText, null)) {
            case (#ok(blob)) blob;
            case (#err(msg)) throw Error.reject("Failed to parse JSON: " # msg);
        };

        let result : ?{{{returnType}}} = from_candid(jsonBlob);
        switch (result) {
            case (?value) value;
            case null throw Error.reject("Failed to deserialize response to {{{returnType}}}");
        }
        {{/returnType}}
    };

{{/operation}}
{{/operations}}

    let operations__ = {
{{#operations}}
{{#operation}}
        {{operationId}};
{{/operation}}
{{/operations}}
    };

    public module class {{classname}}(config : Config__) {
{{#operations}}
{{#operation}}
        {{#summary}}
        /// {{{summary}}}
        {{/summary}}
        {{#notes}}
        /// {{{notes}}}
        {{/notes}}
        public func {{operationId}}({{#allParams}}{{^-first}}, {{/-first}}{{paramName}} : {{#isNullable}}?{{/isNullable}}{{dataType}}{{/allParams}}) : async {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}(){{/returnType}} {
            await* operations__.{{operationId}}(config{{#allParams}}, {{paramName}}{{/allParams}})
        };

{{/operation}}
{{/operations}}
    }
}
